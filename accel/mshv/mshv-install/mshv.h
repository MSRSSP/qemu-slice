#if 0
# This file is generated by cbindgen. DO NOT EDIT
#endif


#ifndef MSHV_BINDINGS_H
#define MSHV_BINDINGS_H

#define CPUID_FLAG_VALID_INDEX 1

typedef enum MshvCpuVendor {
  Unknown,
  Intel,
  AMD,
} MshvCpuVendor;

typedef enum MshvVmExit {
  IoapicEoi,
  Ignore,
  Reset,
  Shutdown,
} MshvVmExit;

typedef struct mshv_hv_message mshv_hv_message;

typedef struct MshvHypervisorC {

} MshvHypervisorC;

typedef struct MshvVmC {

} MshvVmC;

typedef struct MshvVcpuC {

} MshvVcpuC;

typedef struct MshvMemoryRegion {
  uint32_t slot;
  uint64_t guest_phys_addr;
  uint64_t memory_size;
  uint64_t userspace_addr;
  bool readonly;
  bool log_dirty_pages;
} MshvMemoryRegion;

typedef struct StandardRegistersC {
  uint64_t rax;
  uint64_t rbx;
  uint64_t rcx;
  uint64_t rdx;
  uint64_t rsi;
  uint64_t rdi;
  uint64_t rsp;
  uint64_t rbp;
  uint64_t r8;
  uint64_t r9;
  uint64_t r10;
  uint64_t r11;
  uint64_t r12;
  uint64_t r13;
  uint64_t r14;
  uint64_t r15;
  uint64_t rip;
  uint64_t rflags;
} StandardRegistersC;

typedef struct SegmentRegisterC {
  uint64_t base;
  uint32_t limit;
  uint16_t selector;
  uint8_t type_;
  uint8_t present;
  uint8_t dpl;
  uint8_t db;
  uint8_t s;
  uint8_t l;
  uint8_t g;
  uint8_t avl;
  uint8_t unusable;
} SegmentRegisterC;

typedef struct DescriptorTableC {
  uint64_t base;
  uint16_t limit;
} DescriptorTableC;

typedef struct SpecialRegistersC {
  struct SegmentRegisterC cs;
  struct SegmentRegisterC ds;
  struct SegmentRegisterC es;
  struct SegmentRegisterC fs;
  struct SegmentRegisterC gs;
  struct SegmentRegisterC ss;
  struct SegmentRegisterC tr;
  struct SegmentRegisterC ldt;
  struct DescriptorTableC gdt;
  struct DescriptorTableC idt;
  uint64_t cr0;
  uint64_t cr2;
  uint64_t cr3;
  uint64_t cr4;
  uint64_t cr8;
  uint64_t efer;
  uint64_t apic_base;
  uint64_t interrupt_bitmap[4];
} SpecialRegistersC;

typedef struct FpuStateC {
  uint8_t fpr[8][16];
  uint16_t fcw;
  uint16_t fsw;
  uint8_t ftwx;
  uint16_t last_opcode;
  uint64_t last_ip;
  uint64_t last_dp;
  uint8_t xmm[16][16];
  uint32_t mxcsr;
} FpuStateC;

typedef struct MsrEntryC {
  uint32_t index;
  uint32_t resvd;
  uint64_t data;
} MsrEntryC;

struct MshvHypervisorC *mshv_new(void);

struct MshvVmC *mshv_create_vm_with_type(struct MshvHypervisorC *rawmshv, uint64_t vm_type);

struct MshvVcpuC *mshv_new_vcpu(struct MshvVmC *vm, uint8_t vcpu);

void mshv_vm_resume(struct MshvVmC *vm);

void mshv_vm_pause(struct MshvVmC *vm);

int32_t mshv_add_mem(struct MshvVmC *rawvm, const struct MshvMemoryRegion *r);

int32_t mshv_remove_mem(struct MshvVmC *rawvm, const struct MshvMemoryRegion *r);

bool mshv_register_ioevent(struct MshvVmC *rawvm,
                           int rawfd,
                           bool is_mmio,
                           uint64_t addr,
                           uint64_t val,
                           bool is_64bit,
                           bool is_datamatch);

bool mshv_unregister_ioevent(struct MshvVmC *rawvm, int rawfd, bool is_mmio, uint64_t addr);

void mshv_configure_vcpu(struct MshvHypervisorC *rawmshv,
                         struct MshvVcpuC *rawcpu,
                         uint8_t id,
                         enum MshvCpuVendor cpu_vendor,
                         uint8_t die,
                         uint8_t ncore_per_die,
                         uint8_t thread_per_core,
                         const struct StandardRegistersC *regs,
                         const struct SpecialRegistersC *sregs,
                         uint64_t xcr0,
                         const struct FpuStateC *fpu);

void mshv_configure_msr(struct MshvVcpuC *rawcpu, struct MsrEntryC *raw_msrs, uint32_t len);

void mshv_get_vcpu(struct MshvVcpuC *rawcpu,
                   struct StandardRegistersC *regs,
                   struct SpecialRegistersC *sregs,
                   struct FpuStateC *fpu);

bool mshv_set_identity_map_address(struct MshvVmC *rawvm, uint64_t address);

bool mshv_set_tss_address(struct MshvVmC *rawvm, uint64_t address);

bool mshv_create_irq_chip(struct MshvVmC *rawvm);

bool mshv_register_irqfd(struct MshvVmC *rawvm, int fd, uint32_t gsi);

bool mshv_unregister_irqfd(struct MshvVmC *rawvm, int fd, uint32_t gsi);

enum MshvVmExit mshv_run_vcpu(struct MshvVcpuC *rawcpu, struct mshv_hv_message *raw_hv_message);

int32_t mshv_nmi(struct MshvVcpuC *rawcpu);

void mshv_dump_vcpu(struct MshvVcpuC *rawcpu, uint8_t cpu_index);

#endif /* MSHV_BINDINGS_H */

#if 0
# This is a simple test to ensure that trailers do not cause extra newlines in files
#endif
